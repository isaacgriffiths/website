<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#000000">
  <title>Isaac Griffiths</title>
  
  <!-- External stylesheet -->
  <link rel="stylesheet" href="styles.css">
  
  <!-- Favicon: "IG" with Helvetica font -->
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text x='10' y='70' font-family='Helvetica, Arial, sans-serif' font-size='80' font-weight='600' fill='white'>IG</text></svg>" type="image/svg+xml">
  
  <style>
    /* Ensure proper font loading */
    @font-face {
      font-family: 'Helvetica';
      src: local('Helvetica'), local('Helvetica Neue'), local('Arial');
      font-weight: normal;
      font-style: normal;
      font-display: swap;
    }
    
    @font-face {
      font-family: 'Helvetica';
      src: local('Helvetica Bold'), local('Helvetica-Bold'), local('Helvetica Neue Bold'), local('Arial Bold');
      font-weight: bold;
      font-style: normal;
      font-display: swap;
    }
  </style>
</head>
<body class="bg-black text-white min-h-screen">

  <div class="h-screen">
    <!-- Canvas for particles background -->
    <canvas id="particles-canvas" class="particles-canvas"></canvas>
    
    <!-- Custom cursor elements -->
  <div class="cursor-dot">
    <div class="cursor-dot-inner"></div>
  </div>
  <div class="cursor-light" id="cursor-light"></div>
  
    <!-- Main content wrapper -->
    <div class="content-wrapper">
      <div class="name-container">
        <!-- Name header -->
        <h1 class="name-title">Isaac Griffiths</h1>
        
        <!-- Social links - smaller and closer together -->
        <div class="social-links">
        <!-- LinkedIn -->
          <a href="https://www.linkedin.com/in/isaacgriffiths/" target="_blank" rel="noopener noreferrer">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="social-icon w-5 h-5 md:w-6 md:h-6 filter brightness-150 contrast-125">
              <path fill="white" d="M4.98 3.5c0 1.381-1.11 2.5-2.48 2.5s-2.48-1.119-2.48-2.5c0-1.38 1.11-2.5 2.48-2.5s2.48 1.12 2.48 2.5zm.02 4.5h-5v16h5v-16zm7.982 0h-4.968v16h4.969v-8.399c0-4.67 6.029-5.052 6.029 0v8.399h4.988v-10.131c0-7.88-8.922-7.593-11.018-3.714v-2.155z"/>
            </svg>
          </a>

          <!-- GitHub -->
          <a href="https://github.com/isaacgriffiths" target="_blank" rel="noopener noreferrer">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="social-icon w-5 h-5 md:w-6 md:h-6 filter brightness-150 contrast-125">
              <path fill="white" d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
            </svg>
          </a>

          <!-- TikTok -->
          <a href="https://www.tiktok.com/@isaacgriffiths" target="_blank" rel="noopener noreferrer">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="social-icon w-5 h-5 md:w-6 md:h-6 filter brightness-150 contrast-125">
              <path fill="white" d="M16.6 5.82s.51.5 0 0A4.278 4.278 0 0 1 15.54 3h-3.09v12.4a2.592 2.592 0 0 1-2.59 2.5c-1.42 0-2.6-1.16-2.6-2.6c0-1.72 1.66-3.01 3.37-2.48V9.66c-3.45-.46-6.47 2.22-6.47 5.64c0 3.33 2.76 5.7 5.69 5.7c3.14 0 5.69-2.55 5.69-5.7V9.01a7.35 7.35 0 0 0 4.3 1.38V7.3s-1.88.09-3.24-1.48z"/>
            </svg>
          </a>

          <!-- Instagram -->
          <a href="https://www.instagram.com/isaacrgriffiths/" target="_blank" rel="noopener noreferrer">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" class="social-icon w-5 h-5 md:w-6 md:h-6 filter brightness-150 contrast-125">
              <path fill="white" d="M12 2.163c3.204 0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.849 0 3.205-.012 3.584-.069 4.849-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07-3.204 0-3.584-.012-4.849-.07-3.26-.149-4.771-1.699-4.919-4.92-.058-1.265-.07-1.644-.07-4.849 0-3.204.013-3.583.07-4.849.149-3.227 1.664-4.771 4.919-4.919 1.266-.057 1.645-.069 4.849-.069zm0-2.163c-3.259 0-3.667.014-4.947.072-4.358.2-6.78 2.618-6.98 6.98-.059 1.281-.073 1.689-.073 4.948 0 3.259.014 3.668.072 4.948.2 4.358 2.618 6.78 6.98 6.98 1.281.058 1.689.072 4.948.072 3.259 0 3.668-.014 4.948-.072 4.354-.2 6.782-2.618 6.979-6.98.059-1.28.073-1.689.073-4.948 0-3.259-.014-3.667-.072-4.947-.196-4.354-2.617-6.78-6.979-6.98-1.281-.059-1.69-.073-4.949-.073zm0 5.838c-3.403 0-6.162 2.759-6.162 6.162s2.759 6.163 6.162 6.163 6.162-2.759 6.162-6.163c0-3.403-2.759-6.162-6.162-6.162zm0 10.162c-2.209 0-4-1.79-4-4 0-2.209 1.791-4 4-4s4 1.791 4 4c0 2.21-1.791 4-4 4zm6.406-11.845c-.796 0-1.441.645-1.441 1.44s.645 1.44 1.441 1.44c.795 0 1.439-.645 1.439-1.44s-.644-1.44-1.439-1.44z"/>
            </svg>
          </a>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Initialize cursor state
    const mousePosition = { x: 0, y: 0 };
    const cursorLight = document.querySelector('.cursor-light');

    // Check if the device is mobile or tablet
    function isMobileOrTablet() {
      return window.matchMedia('(max-width: 768px)').matches;
    }

    // Handle cursor movement
    function handleMouseMove(e) {
      // Only update cursor on desktop
      if (isMobileOrTablet()) return;
      
      // Update state for the glow effect
      mousePosition.x = e.clientX;
      mousePosition.y = e.clientY;
      
      // Update CSS variables for cursor dot
      document.documentElement.style.setProperty('--x', `${e.clientX}px`);
      document.documentElement.style.setProperty('--y', `${e.clientY}px`);
      
      // Apply browser-specific prefixes for better compatibility
      const cursorDot = document.querySelector('.cursor-dot');
      if (cursorDot) {
        cursorDot.style.transform = `translate(calc(${e.clientX}px - 50%), calc(${e.clientY}px - 50%))`;
        cursorDot.style.webkitTransform = `translate(calc(${e.clientX}px - 50%), calc(${e.clientY}px - 50%))`;
        cursorDot.style.mozTransform = `translate(calc(${e.clientX}px - 50%), calc(${e.clientY}px - 50%))`;
        
        // Make sure the cursor dot is visible and properly rendered as an orb
        cursorDot.style.width = 'var(--cursor-size)';
        cursorDot.style.height = 'var(--cursor-size)';
        cursorDot.style.backgroundColor = 'rgba(255, 255, 255, 0.95)';
        cursorDot.style.boxShadow = '0 0 12px 4px rgba(200, 220, 255, 0.8)';
        cursorDot.style.borderRadius = '50%';
        cursorDot.style.opacity = '1';
      }
      
      // Create a smoother light gradient with reduced range
      const gradientSize = '800px'; // Reduced from 1800px
      const glowColor1 = 'rgba(150, 180, 255, 0.15)'; // Slightly increased opacity
      const glowColor2 = 'rgba(140, 170, 240, 0.12)';
      const glowColor3 = 'rgba(130, 160, 230, 0.09)';
      const glowColor4 = 'rgba(120, 150, 220, 0.06)';
      const glowColor5 = 'rgba(110, 140, 210, 0.03)';
      const transparentColor = 'transparent';
      
      // Update the cursor light background with smoother transitions and shorter distance
      cursorLight.style.background = `radial-gradient(circle ${gradientSize} at ${mousePosition.x}px ${mousePosition.y}px, ${glowColor1} 0%, ${glowColor2} 15%, ${glowColor3} 30%, ${glowColor4} 45%, ${glowColor5} 60%, ${transparentColor} 75%)`;
      cursorLight.style.backgroundImage = `-webkit-radial-gradient(${mousePosition.x}px ${mousePosition.y}px, circle, ${glowColor1} 0%, ${glowColor2} 15%, ${glowColor3} 30%, ${glowColor4} 45%, ${glowColor5} 60%, ${transparentColor} 75%)`;
      cursorLight.style.backgroundImage = `-moz-radial-gradient(${mousePosition.x}px ${mousePosition.y}px, circle, ${glowColor1} 0%, ${glowColor2} 15%, ${glowColor3} 30%, ${glowColor4} 45%, ${glowColor5} 60%, ${transparentColor} 75%)`;
      
      // Update particle positions based on mouse movement
      if (particles) {
        const mouseVector = { x: e.clientX / window.innerWidth, y: e.clientY / window.innerHeight };
        updateParticleAttraction(mouseVector);
      }
      
      // Set mouse as actively moving
      isMouseMoving = true;
      
      // Clear previous idle timer
      if (mouseIdleTimer) {
        clearTimeout(mouseIdleTimer);
      }
      
      // Set a new idle timer - mouse is considered idle after 3 seconds without movement
      mouseIdleTimer = setTimeout(() => {
        isMouseMoving = false;
      }, 3000);
      
      // Increment counter for mouse movement
      mouseMovementCounter++;
      
      // Enable shooting star spawning after sufficient mouse movement
      if (mouseMovementCounter > 40 && !canSpawnShootingStar) {
        canSpawnShootingStar = true;
        scheduleNextShootingStar();
      }
    }

    // Add hover effects for interactive elements
    function initializeCursorEffects() {
      if (isMobileOrTablet()) return;
      
      const links = document.querySelectorAll('a');
      const cursorDot = document.querySelector('.cursor-dot');
      
      // Apply hover effect on links
      links.forEach(link => {
        link.addEventListener('mouseenter', () => {
          if (cursorDot) {
            cursorDot.style.width = '16px';
            cursorDot.style.height = '16px';
            cursorDot.style.backgroundColor = 'rgba(255, 255, 255, 1)';
            cursorDot.style.boxShadow = '0 0 12px 4px rgba(255, 255, 255, 0.7)';
          }
        });
        
        link.addEventListener('mouseleave', () => {
          if (cursorDot) {
            cursorDot.style.width = 'var(--cursor-size)';
            cursorDot.style.height = 'var(--cursor-size)';
            cursorDot.style.backgroundColor = 'rgba(255, 255, 255, 0.95)';
            cursorDot.style.boxShadow = '0 0 10px 3px rgba(255, 255, 255, 0.6)';
          }
        });
      });
    }

    // Particles system
    let canvas, ctx, particles;
    let shootingStar = null;
    const particleCount = 55; // Increased count for more particles
    let mouseMovementCounter = 0; // Track mouse movement
    let canSpawnShootingStar = false; // Flag to control shooting star spawning
    let isMouseMoving = false; // Track active mouse movement
    let mouseIdleTimer = null; // Timer for detecting mouse idle state
    let hasRareConstellation = false; // Flag for rare constellation
    let constellationPoints = []; // Store constellation points
    let constellationName = ""; // Name of the constellation
    let constellationConnections = []; // Store constellation connections

    function initParticles() {
      canvas = document.getElementById('particles-canvas');
      if (!canvas) return;
      
      ctx = canvas.getContext('2d');
      
      // Set canvas size
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);
      
      // Determine if this page load will have the rare constellation (1 in 20 chance)
      hasRareConstellation = Math.random() < 0.15; // Increased from 0.05 to 0.15 (15% chance)
      
      // Create particles
      particles = [];
      
      // Get the position of name and links to avoid spawning particles near them
      const nameContainer = document.querySelector('.name-container');
      const nameRect = nameContainer.getBoundingClientRect();
      
      // Calculate safe margins around name and links (expanded area to avoid)
      const safeMargin = {
        top: nameRect.top - 50,
        left: nameRect.left - 50,
        right: nameRect.right + 50,
        bottom: nameRect.bottom + 50
      };
      
      // Keep track of particle positions to maintain minimum distance between them
      const particlePositions = [];
      const minimumDistance = 50; // Reduced minimum distance to allow more particles
      
      // If we're going to have a rare constellation, set it up
      if (hasRareConstellation) {
        setupConstellation(safeMargin);
      }
      
      for (let i = 0; i < particleCount; i++) {
        // Create a particle outside of the safe zone and far enough from other particles
        let x, y, isValidPosition;
        let attempts = 0;
        const maxAttempts = 50; // Prevent infinite loops
        
        do {
          x = Math.random() * canvas.width;
          y = Math.random() * canvas.height;
          
          // Check if in safe zone
          const isInSafeZone = (
            x > safeMargin.left && 
            x < safeMargin.right && 
            y > safeMargin.top && 
            y < safeMargin.bottom
          );
          
          // Check distance from other particles
          let isTooClose = false;
          for (const pos of particlePositions) {
            const dist = Math.sqrt(Math.pow(x - pos.x, 2) + Math.pow(y - pos.y, 2));
            if (dist < minimumDistance) {
              isTooClose = true;
              break;
            }
          }
          
          isValidPosition = !isInSafeZone && !isTooClose;
          attempts++;
          
          // If we can't find a position after many attempts, reduce constraints
          if (attempts > maxAttempts) {
            isValidPosition = !isInSafeZone; // Just avoid safe zone
          }
          
        } while (!isValidPosition && attempts < maxAttempts * 2);
        
        // Store the position
        particlePositions.push({ x, y });
        
        // Create wider variety in depth factor (0.2 to 1.2) for more size variation
        const depthFactor = 0.2 + Math.random() * 1.0;
        
        // Determine particle type - planets more common than stars, but both rarer than basic particles
        // 10% chance for planets, 5% chance for stars, 85% for basic particles
        const rand = Math.random();
        const isPlanet = rand < 0.10;
        const isStar = !isPlanet && rand < 0.15;
        
        if (isPlanet) {
          // Determine the specific type of planet
          const planetType = Math.random();
          let planetHue, planetSat, planetLight;
          
          // Create planet-like particle with more variety in types
          if (planetType < 0.25) {
            // Earth-like blue/green water world
            planetHue = 180 + Math.random() * 40;
            planetSat = 60 + Math.random() * 30;
            planetLight = 45 + Math.random() * 15;
          } else if (planetType < 0.5) {
            // Mars-like red/orange desert planet
            planetHue = 0 + Math.random() * 30;
            planetSat = 70 + Math.random() * 20;
            planetLight = 40 + Math.random() * 15;
          } else if (planetType < 0.7) {
            // Gas giant (Jupiter-like)
            planetHue = 30 + Math.random() * 20;
            planetSat = 50 + Math.random() * 40;
            planetLight = 50 + Math.random() * 20;
          } else if (planetType < 0.85) {
            // Saturn/Neptune-like pale planet
            planetHue = 200 + Math.random() * 40;
            planetSat = 40 + Math.random() * 30;
            planetLight = 60 + Math.random() * 20;
          } else {
            // Exotic planet (unusual colors)
            planetHue = Math.random() < 0.5 ? 280 + Math.random() * 60 : 120 + Math.random() * 30;
            planetSat = 60 + Math.random() * 30;
            planetLight = 45 + Math.random() * 25;
          }
          
          // Determine if planet has rings, stripes, or other features
          const hasRings = Math.random() < 0.6;
          const hasStripes = !hasRings && Math.random() < 0.4;
          const hasClouds = Math.random() < 0.3;
          
          // Determine ring properties if present
          const ringWidth = hasRings ? 0.3 + Math.random() * 0.6 : 0;
          const ringTilt = hasRings ? Math.random() * Math.PI : 0;
          const ringHue = hasRings ? (Math.random() < 0.7 ? planetHue + (Math.random() * 40 - 20) : 
                                    Math.random() < 0.5 ? 30 + Math.random() * 30 : 180 + Math.random() * 40) : 0;
          
          particles.push({
            x: x,
            y: y,
            baseSize: 2 + (Math.random() * 3 * depthFactor), // Reduced planet size
            size: 2 + (Math.random() * 3 * depthFactor),
            maxSize: 4 + (Math.random() * 8 * depthFactor), // Reduced max growth
            speedX: (Math.random() - 0.5) * 0.07 * depthFactor, // Slower than stars
            speedY: (Math.random() - 0.5) * 0.07 * depthFactor,
            opacity: 0.2 + (Math.random() * 0.5 * depthFactor),
            growFactor: 0,
            hue: planetHue,
            saturation: planetSat,
            lightness: planetLight,
            hasRings: hasRings, 
            hasStripes: hasStripes,
            hasClouds: hasClouds,
            ringColor: ringHue,
            ringWidth: ringWidth,
            ringAngle: ringTilt,
            numStripes: hasStripes ? 2 + Math.floor(Math.random() * 4) : 0,
            stripeContrast: hasStripes ? 0.2 + Math.random() * 0.3 : 0,
            rotationSpeed: (Math.random() - 0.5) * 0.001,
            rotation: Math.random() * Math.PI * 2,
            cloudOpacity: hasClouds ? 0.3 + Math.random() * 0.4 : 0,
            cloudCoverage: hasClouds ? 0.3 + Math.random() * 0.5 : 0,
            depth: depthFactor,
            isPlanet: true,
            isStar: false,
            isBasic: false
          });
        } else if (isStar) {
          // Determine star type
          const starType = Math.random();
          let starHue, starSat, starLight, starGlow;
          
          if (starType < 0.3) {
            // Blue star (hot)
            starHue = 200 + Math.random() * 40;
            starSat = 70 + Math.random() * 30;
            starLight = 75 + Math.random() * 15;
            starGlow = 0.6 + Math.random() * 0.4;
          } else if (starType < 0.6) {
            // White star
            starHue = Math.random() * 360; // Any hue, but low saturation
            starSat = 10 + Math.random() * 20;
            starLight = 85 + Math.random() * 15;
            starGlow = 0.5 + Math.random() * 0.4;
          } else if (starType < 0.8) {
            // Yellow star (sun-like)
            starHue = 40 + Math.random() * 20;
            starSat = 70 + Math.random() * 30;
            starLight = 70 + Math.random() * 20;
            starGlow = 0.5 + Math.random() * 0.3;
          } else {
            // Red star (cool)
            starHue = 0 + Math.random() * 20;
            starSat = 70 + Math.random() * 30;
            starLight = 60 + Math.random() * 15;
            starGlow = 0.4 + Math.random() * 0.3;
          }
          
          // Determine if it's a blinking/pulsing star or a stable one
          const pulsing = Math.random() < 0.7;
          const twinkleSpeed = pulsing ? 0.004 + Math.random() * 0.05 : 0.001 + Math.random() * 0.003;
          
          // Determine if it's a binary star
          const isBinary = Math.random() < 0.15;
          const binaryDistance = isBinary ? 0.5 + Math.random() * 1.0 : 0;
          const binaryAngle = isBinary ? Math.random() * Math.PI * 2 : 0;
          const binarySize = isBinary ? 0.4 + Math.random() * 0.3 : 0; // Relative to primary star
          
          // Create star-like particle with more variation
          particles.push({
            x: x,
            y: y,
            baseSize: 0.3 + (Math.random() * 1.5 * depthFactor), // Reduced star size
            size: 0.3 + (Math.random() * 1.5 * depthFactor),
            maxSize: 1.5 + (Math.random() * 5 * depthFactor), // Reduced max growth
            speedX: (Math.random() - 0.5) * 0.15 * depthFactor, // Stars move faster
            speedY: (Math.random() - 0.5) * 0.15 * depthFactor,
            opacity: 0.35 + (Math.random() * 0.65 * depthFactor), // Stars are brighter with more variation
            growFactor: 0,
            hue: starHue,
            saturation: starSat,
            lightness: starLight,
            glowStrength: starGlow,
            pulsing: pulsing,
            twinkleSpeed: twinkleSpeed,
            twinklePhase: Math.random() * Math.PI * 2, // Initial phase
            rayIntensity: Math.random() * 0.6 + 0.2, // Varied ray intensity
            rayCount: Math.floor(Math.random() * 3) * 2 + 4, // 4, 6, or 8 rays
            isBinary: isBinary,
            binaryDistance: binaryDistance,
            binaryAngle: binaryAngle, 
            binarySize: binarySize,
            binaryHue: starHue + (Math.random() * 80 - 40),
            binaryOrbitSpeed: 0.001 + Math.random() * 0.004,
            binaryPhase: Math.random() * Math.PI * 2,
            depth: depthFactor,
            isPlanet: false,
            isStar: true, 
            isBasic: false
          });
        } else {
          // Create basic particle (more common) - now with more subtle variations
          // Choose from several color schemes for basic particles
          let particleHue, particleSat;
          const colorScheme = Math.random();
          
          if (colorScheme < 0.6) {
            // Standard blue to cyan
            particleHue = 180 + Math.random() * 60;
            particleSat = 30 + Math.random() * 40;
          } else if (colorScheme < 0.8) {
            // Subtle purple
            particleHue = 240 + Math.random() * 30;
            particleSat = 20 + Math.random() * 30;
          } else {
            // Subtle gold/yellow
            particleHue = 40 + Math.random() * 20;
            particleSat = 20 + Math.random() * 30;
          }
          
          particles.push({
            x: x,
            y: y,
            baseSize: 0.2 + (Math.random() * 1.8 * depthFactor), // Basic particles are smaller
            size: 0.2 + (Math.random() * 1.8 * depthFactor),
            maxSize: 1.5 + (Math.random() * 5 * depthFactor),
            speedX: (Math.random() - 0.5) * 0.2 * depthFactor, 
            speedY: (Math.random() - 0.5) * 0.2 * depthFactor,
            opacity: 0.2 + (Math.random() * 0.4 * depthFactor),
            growFactor: 0,
            hue: particleHue, 
            saturation: particleSat,
            depth: depthFactor,
            isPlanet: false,
            isStar: false,
            isBasic: true
          });
        }
      }
      
      // Initialize shooting star timer
      initShootingStar();
      
      // Start animation
      animateParticles();
    }

    function initShootingStar() {
      // Don't schedule immediately - wait for mouse movement
      canSpawnShootingStar = false;
    }

    function scheduleNextShootingStar() {
      // Only schedule if enabled by mouse movement and mouse is actively moving
      if (!canSpawnShootingStar) return;
      
      // Random interval between 15-30 seconds (much less frequent)
      const nextStarTime = 15000 + Math.random() * 15000;
      
      setTimeout(() => {
        // Only create shooting star if mouse is actively moving
        if (isMouseMoving) {
          createShootingStar();
        }
        // Schedule the next one regardless
        scheduleNextShootingStar();
      }, nextStarTime);
    }

    function createShootingStar() {
      // Ensure the star travels horizontally with a large arc
      
      // Ensure the star travels across the entire window
      const maxDimension = Math.max(canvas.width, canvas.height);
      
      // Horizontal direction only - randomly from left or right
      const fromRight = Math.random() > 0.5;
      
      // Start position
      let startX, startY;
      
      // Randomly choose y position across the entire screen
      startY = Math.random() * canvas.height * 0.8 + canvas.height * 0.1; // Keep away from extreme edges
      
      if (fromRight) {
        startX = canvas.width + 100; // Start from right
      } else {
        startX = -100; // Start from left
      }
      
      // Determine end position (opposite side)
      const endX = fromRight ? -200 : canvas.width + 200;
      
      // End Y should be somewhat close to start Y for predominantly horizontal movement
      // but with some variation
      const endY = startY + (Math.random() * canvas.height * 0.4 - canvas.height * 0.2);
      
      // Midpoint for control point
      const midX = (startX + endX) / 2;
      
      // Create a large arc - control point is far above or below the midpoint
      const arcDirection = Math.random() > 0.5 ? -1 : 1; // Random up or down arc
      const arcHeight = arcDirection * (canvas.height * 0.5 + Math.random() * canvas.height * 0.6); // Larger arc
      const controlY = (startY + endY) / 2 + arcHeight;
      
      shootingStar = {
        x: startX,
        y: startY,
        startX: startX,
        startY: startY,
        controlX: midX,
        controlY: controlY,
        endX: endX,
        endY: endY,
        size: 3 + Math.random() * 3, // Larger core
        trail: [], // Store trail positions
        trailLength: 30 + Math.random() * 40, // Longer trail
        speed: 4 + Math.random() * 7, // Much slower speed
        progress: 0, // 0 to 1
        brightness: 0.95 + Math.random() * 0.05, // Brighter
        hue: 180 + Math.random() * 60, // Cyan to light blue
        lightRadius: 400 + Math.random() * 450 // Larger light radius
      };
    }

    function updateShootingStar() {
      if (!shootingStar) return;
      
      // Update progress
      shootingStar.progress += shootingStar.speed / 1000;
      
      // Calculate new position using quadratic bezier curve for arc motion
      // B(t) = (1-t)²P0 + 2(1-t)tP1 + t²P2, where t is progress (0 to 1)
      const t = shootingStar.progress;
      const mt = 1 - t;
      
      // Quadratic Bezier formula for arc
      shootingStar.x = mt * mt * shootingStar.startX + 
                       2 * mt * t * shootingStar.controlX + 
                       t * t * shootingStar.endX;
                       
      shootingStar.y = mt * mt * shootingStar.startY + 
                       2 * mt * t * shootingStar.controlY + 
                       t * t * shootingStar.endY;
      
      // Add current position to trail
      shootingStar.trail.unshift({ x: shootingStar.x, y: shootingStar.y });
      
      // Limit trail length
      if (shootingStar.trail.length > shootingStar.trailLength) {
        shootingStar.trail.pop();
      }
      
      // Check if shooting star has completed its journey
      if (shootingStar.progress >= 1 || 
          shootingStar.x < -200 || shootingStar.x > canvas.width + 200 ||
          shootingStar.y < -200 || shootingStar.y > canvas.height + 200) {
        shootingStar = null;
      }
    }

    function drawShootingStar() {
      if (!shootingStar) return;
      
      // Draw the light glow first (larger than the cursor light)
      ctx.beginPath();
      const gradient = ctx.createRadialGradient(
        shootingStar.x, shootingStar.y, 0,
        shootingStar.x, shootingStar.y, shootingStar.lightRadius
      );
      gradient.addColorStop(0, `hsla(${shootingStar.hue}, 100%, 80%, ${shootingStar.brightness * 0.25})`);
      gradient.addColorStop(0.1, `hsla(${shootingStar.hue}, 100%, 80%, ${shootingStar.brightness * 0.15})`);
      gradient.addColorStop(0.3, `hsla(${shootingStar.hue}, 100%, 80%, ${shootingStar.brightness * 0.08})`);
      gradient.addColorStop(0.5, `hsla(${shootingStar.hue}, 100%, 80%, ${shootingStar.brightness * 0.03})`);
      gradient.addColorStop(1, 'transparent');
      
      ctx.fillStyle = gradient;
      ctx.arc(shootingStar.x, shootingStar.y, shootingStar.lightRadius, 0, Math.PI * 2);
      ctx.fill();
      
      // Draw the trail with gradient opacity and larger size
      for (let i = 0; i < shootingStar.trail.length; i++) {
        const point = shootingStar.trail[i];
        const trailOpacity = shootingStar.brightness * (1 - i / shootingStar.trail.length);
        const trailSize = shootingStar.size * (1 - i / shootingStar.trail.length) * 1.2;
        
        // Draw trail glow
        ctx.beginPath();
        ctx.arc(point.x, point.y, trailSize * 4, 0, Math.PI * 2);
        ctx.fillStyle = `hsla(${shootingStar.hue}, 100%, 80%, ${trailOpacity * 0.15})`;
        ctx.fill();
        
        // Draw trail core
        ctx.beginPath();
        ctx.arc(point.x, point.y, trailSize, 0, Math.PI * 2);
        ctx.fillStyle = `hsla(${shootingStar.hue}, 100%, 85%, ${trailOpacity})`;
        ctx.fill();
      }
      
      // Draw the shooting star head with stronger glow
      ctx.beginPath();
      ctx.arc(shootingStar.x, shootingStar.y, shootingStar.size * 5, 0, Math.PI * 2);
      ctx.fillStyle = `hsla(${shootingStar.hue}, 90%, 85%, ${shootingStar.brightness * 0.3})`;
      ctx.fill();
      
      ctx.beginPath();
      ctx.arc(shootingStar.x, shootingStar.y, shootingStar.size * 2, 0, Math.PI * 2);
      ctx.fillStyle = `hsla(${shootingStar.hue}, 95%, 90%, ${shootingStar.brightness * 0.6})`;
      ctx.fill();
      
      // Core of the star
      ctx.beginPath();
      ctx.arc(shootingStar.x, shootingStar.y, shootingStar.size, 0, Math.PI * 2);
      ctx.fillStyle = `hsla(${shootingStar.hue}, 100%, 100%, ${shootingStar.brightness})`;
      ctx.shadowColor = `hsla(${shootingStar.hue}, 100%, 90%, 0.9)`;
      ctx.shadowBlur = 20; // Stronger blur
      ctx.fill();
      ctx.shadowBlur = 0; // Reset shadow for other elements
    }

    function resizeCanvas() {
      if (canvas) {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
    }

    function updateParticleAttraction(mousePos) {
      const attractionDistance = 0.15; // Distance (as percentage of screen) at which particles are affected
      const attraction = 0.02; // Strength of attraction
      const growDistance = 0.12; // Distance at which particles start growing
      
      particles.forEach(p => {
        // Calculate normalized distance from mouse
        const dx = mousePos.x - (p.x / canvas.width);
        const dy = mousePos.y - (p.y / canvas.height);
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // Handle size growth based on proximity to cursor
        if (distance < growDistance) {
          // Calculate growth factor (0 to 1)
          p.growFactor = 1 - (distance / growDistance);
          
          // Apply size scaling based on growth factor (scaled by depth)
          p.size = p.baseSize + ((p.maxSize - p.baseSize) * p.growFactor);
        } else {
          // Gradually return to base size
          p.growFactor *= 0.95;
          p.size = p.baseSize + ((p.maxSize - p.baseSize) * p.growFactor);
        }
        
        // Move particles based on cursor position
        if (distance < attractionDistance) {
          // Apply slight attraction effect scaled by depth
          const factor = (attractionDistance - distance) * attraction * p.depth;
          p.speedX += dx * factor;
          p.speedY += dy * factor;
          
          // Add slight randomness to movement
          p.speedX += (Math.random() - 0.5) * 0.005 * p.depth;
          p.speedY += (Math.random() - 0.5) * 0.005 * p.depth;
        }
      });
    }

    function animateParticles() {
      if (!canvas || !ctx || !particles) return;
      
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Update and draw shooting star
      updateShootingStar();
      drawShootingStar();
      
      // If we have a rare constellation, draw the connections first
      if (hasRareConstellation) {
        drawConstellation();
      }
      
      // Draw and update particles
      particles.forEach(p => {
        // Apply velocity
        p.x += p.speedX;
        p.y += p.speedY;
        
        // Add very slight random movement scaled by depth
        p.x += (Math.random() - 0.5) * 0.1 * p.depth;
        p.y += (Math.random() - 0.5) * 0.1 * p.depth;
        
        // Update rotation for planets if they have it
        if (p.isPlanet && p.rotationSpeed) {
          p.rotation += p.rotationSpeed;
          if (p.rotation > Math.PI * 2) p.rotation -= Math.PI * 2;
          if (p.rotation < 0) p.rotation += Math.PI * 2;
        }
        
        // Update binary star phase if applicable
        if (p.isStar && p.isBinary && p.binaryOrbitSpeed) {
          p.binaryPhase += p.binaryOrbitSpeed;
          if (p.binaryPhase > Math.PI * 2) p.binaryPhase -= Math.PI * 2;
        }
        
        // Special handling for constellation stars
        if (p.inConstellation) {
          // Limit movement more strictly for constellation stars
          const originalX = constellationPoints.find(cp => cp.index === p.constellationIndex).x;
          const originalY = constellationPoints.find(cp => cp.index === p.constellationIndex).y;
          
          // Gently pull back to original position
          p.x += (originalX - p.x) * 0.02;
          p.y += (originalY - p.y) * 0.02;
          
          // Limit max distance from original position
          const dx = p.x - originalX;
          const dy = p.y - originalY;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const maxDrift = 5;
          
          if (dist > maxDrift) {
            p.x = originalX + (dx / dist) * maxDrift;
            p.y = originalY + (dy / dist) * maxDrift;
          }
        }
        
        // Dampen speed
        p.speedX *= 0.98;
        p.speedY *= 0.98;
        
        // Contain within canvas with bounce effect
        if (p.x < p.size) {
          p.x = p.size;
          p.speedX *= -0.7;
        }
        if (p.x > canvas.width - p.size) {
          p.x = canvas.width - p.size;
          p.speedX *= -0.7;
        }
        if (p.y < p.size) {
          p.y = p.size;
          p.speedY *= -0.7;
        }
        if (p.y > canvas.height - p.size) {
          p.y = canvas.height - p.size;
          p.speedY *= -0.7;
        }
        
        // Calculate distance from cursor to determine visibility
        const dx = mousePosition.x - p.x;
        const dy = mousePosition.y - p.y;
        const distanceToCursor = Math.sqrt(dx * dx + dy * dy);
        
        // Light coverage radius (should match the cursor light gradient size)
        const lightRadius = 400; // Half of the 800px gradient
        
        // Special case: constellation stars are always visible with a minimum brightness
        let visibility = 0;
        
        if (p.inConstellation) {
          // Constellation stars are always at least partly visible
          visibility = Math.max(0.4, Math.min(1, 1 - (distanceToCursor / (lightRadius * 1.5)))); // Increased minimum visibility and radius
        } else if (distanceToCursor < lightRadius) {
          // Regular particles only visible near cursor
          visibility = Math.max(0, 1 - (distanceToCursor / lightRadius));
          
          // Make particles more visible when they grow due to cursor proximity
          if (p.growFactor > 0) {
            visibility = Math.max(visibility, p.growFactor * 0.8 + visibility * 0.2);
          }
        }
        
        if (visibility > 0) {  
          if (p.isPlanet) {
            // Draw planet-like particle
            
            // Base planet color - use lightness from the planet properties
            const saturation = p.saturation;
            const lightness = p.lightness || (50 + 20 * p.depth);
            
            // Save context for rotation if needed
            if (p.hasStripes || p.rotation) {
              ctx.save();
              ctx.translate(p.x, p.y);
              ctx.rotate(p.rotation || 0);
            }
            
            // Draw the planet body
            if (p.hasStripes) {
              // For striped planets (like Jupiter)
              const stripeWidth = p.size / (p.numStripes * 2 - 1);
              
              for (let i = 0; i < p.numStripes * 2 - 1; i++) {
                const isOdd = i % 2;
                const yOffset = -p.size + i * stripeWidth;
                
                ctx.fillStyle = `hsla(${p.hue}, ${p.saturation}%, 
                  ${lightness + (isOdd ? -p.stripeContrast * 20 : 0)}%, 
                  ${p.opacity * visibility})`;
                  
                ctx.beginPath();
                ctx.rect(-p.size, yOffset, p.size * 2, stripeWidth);
                ctx.fill();
              }
              
              // Clip to circle
              ctx.beginPath();
              ctx.arc(0, 0, p.size, 0, Math.PI * 2);
              ctx.clip();
              
              // Add shading
              const gradient = ctx.createRadialGradient(
                -p.size * 0.3, -p.size * 0.3, 0,
                0, 0, p.size
              );
              
              gradient.addColorStop(0, `hsla(${p.hue}, ${saturation}%, ${lightness + 15}%, 0.4)`);
              gradient.addColorStop(0.7, `hsla(${p.hue}, ${saturation}%, ${lightness}%, 0.1)`);
              gradient.addColorStop(1, `hsla(${p.hue}, ${saturation}%, ${lightness - 15}%, 0.5)`);
              
              ctx.fillStyle = gradient;
              ctx.fillRect(-p.size, -p.size, p.size * 2, p.size * 2);
              
            } else if (p.hasStripes || p.rotation) {
              // Normal planet with gradient (call from inside the rotation save block)
              ctx.beginPath();
              ctx.arc(0, 0, p.size, 0, Math.PI * 2);
              
              const planetGradient = ctx.createRadialGradient(
                -p.size * 0.3, -p.size * 0.3, 0,
                0, 0, p.size
              );
              
              // Create a shaded effect to make it look more 3D
              planetGradient.addColorStop(0, `hsla(${p.hue}, ${saturation}%, ${lightness + 15}%, ${p.opacity * visibility})`);
              planetGradient.addColorStop(0.7, `hsla(${p.hue}, ${saturation}%, ${lightness}%, ${p.opacity * visibility})`);
              planetGradient.addColorStop(1, `hsla(${p.hue}, ${saturation}%, ${lightness - 15}%, ${p.opacity * visibility})`);
              
              ctx.fillStyle = planetGradient;
              ctx.fill();
            } else {
              // Draw regular planet without rotation
              ctx.beginPath();
              ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
              
              const planetGradient = ctx.createRadialGradient(
                p.x - p.size * 0.3, p.y - p.size * 0.3, 0,
                p.x, p.y, p.size
              );
              
              // Create a shaded effect to make it look more 3D
              planetGradient.addColorStop(0, `hsla(${p.hue}, ${saturation}%, ${lightness + 15}%, ${p.opacity * visibility})`);
              planetGradient.addColorStop(0.7, `hsla(${p.hue}, ${saturation}%, ${lightness}%, ${p.opacity * visibility})`);
              planetGradient.addColorStop(1, `hsla(${p.hue}, ${saturation}%, ${lightness - 15}%, ${p.opacity * visibility})`);
              
              ctx.fillStyle = planetGradient;
              ctx.fill();
            }
            
            // Draw clouds if the planet has them
            if (p.hasClouds) {
              if (p.hasStripes || p.rotation) {
                // Drawing in the rotated context
                ctx.beginPath();
                ctx.arc(0, 0, p.size * 1.03, 0, Math.PI * 2);
                
                // Cloud pattern
                const cloudPattern = ctx.createRadialGradient(
                  p.size * 0.2, p.size * 0.2, 0,
                  0, 0, p.size * 1.1
                );
                
                // Pattern for clouds
                cloudPattern.addColorStop(0, `hsla(0, 0%, 100%, ${p.cloudOpacity * visibility * 0.5})`);
                cloudPattern.addColorStop(p.cloudCoverage, `hsla(0, 0%, 100%, ${p.cloudOpacity * visibility * 0.2})`);
                cloudPattern.addColorStop(1, `hsla(0, 0%, 100%, 0)`);
                
                ctx.fillStyle = cloudPattern;
                ctx.fill();
              } else {
                // Drawing without rotation
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * 1.03, 0, Math.PI * 2);
                
                // Cloud pattern
                const cloudPattern = ctx.createRadialGradient(
                  p.x + p.size * 0.2, p.y + p.size * 0.2, 0,
                  p.x, p.y, p.size * 1.1
                );
                
                // Pattern for clouds
                cloudPattern.addColorStop(0, `hsla(0, 0%, 100%, ${p.cloudOpacity * visibility * 0.5})`);
                cloudPattern.addColorStop(p.cloudCoverage, `hsla(0, 0%, 100%, ${p.cloudOpacity * visibility * 0.2})`);
                cloudPattern.addColorStop(1, `hsla(0, 0%, 100%, 0)`);
                
                ctx.fillStyle = cloudPattern;
                ctx.fill();
              }
            }
            
            // Restore context if we saved it
            if (p.hasStripes || p.rotation) {
              ctx.restore();
            }
            
            // Draw rings for planets that have them
            if (p.hasRings) {
              // Save context for rotation
              ctx.save();
              
              // Translate to planet center, rotate, then translate back
              ctx.translate(p.x, p.y);
              ctx.rotate(p.ringAngle);
              
              // Draw the rings as ellipse
              ctx.beginPath();
              ctx.ellipse(0, 0, p.size * (1 + p.ringWidth), p.size * (1 + p.ringWidth) * 0.3, 0, 0, Math.PI * 2);
              ctx.strokeStyle = `hsla(${p.ringColor}, 70%, 60%, ${p.opacity * 0.6 * visibility})`;
              ctx.lineWidth = p.size * 0.2;
              ctx.stroke();
              
              // Add inner shadow for the rings to give them depth
              ctx.beginPath();
              ctx.ellipse(0, 0, p.size * (1 + p.ringWidth * 0.8), p.size * (1 + p.ringWidth * 0.8) * 0.3, 0, 0, Math.PI * 2);
              ctx.strokeStyle = `hsla(${p.ringColor}, 70%, 50%, ${p.opacity * 0.3 * visibility})`;
              ctx.lineWidth = p.size * 0.1;
              ctx.stroke();
              
              // Restore context
              ctx.restore();
            }
            
            // Add subtle glow for planets
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size * 1.5, 0, Math.PI * 2);
            ctx.fillStyle = `hsla(${p.hue}, ${saturation}%, ${lightness}%, ${p.opacity * 0.1 * visibility})`;
            ctx.fill();
            
          } else if (p.isStar) {
            // Draw star-like particle with twinkle effect
            
            // Update twinkle phase
            if (p.pulsing) {
              p.twinklePhase += p.twinkleSpeed;
              if (p.twinklePhase > Math.PI * 2) p.twinklePhase -= Math.PI * 2;
            }
            
            // Twinkle factor oscillates between 0.7 and 1.3
            let twinkleFactor;
            
            if (p.inConstellation) {
              // Constellation stars have stronger twinkling
              twinkleFactor = 1 + 0.4 * Math.sin(p.twinklePhase);
            } else if (p.pulsing) {
              twinkleFactor = 1 + 0.3 * Math.sin(p.twinklePhase);
            } else {
              twinkleFactor = 1;
            }
            
            // Adjust star size with twinkle
            const starSize = p.size * twinkleFactor;
            
            // Adjust star brightness with twinkle (inverse to size)
            const twinkleBrightness = p.pulsing ? 1 + 0.2 * Math.cos(p.twinklePhase + Math.PI) : 1;
            
            // Use lightness from star properties
            const starLightness = p.lightness || 80;
            
            // Special glow for constellation stars
            let extraGlow = p.inConstellation ? 1.5 : 1;
            let extraRayIntensity = p.inConstellation ? 1.8 : 1;
            
            // Draw main star
            drawStar(p.x, p.y, starSize, p.hue, p.saturation, starLightness, p.opacity, 
                    twinkleBrightness, visibility, p.glowStrength * extraGlow, 
                    p.rayIntensity * extraRayIntensity, p.rayCount);
            
            // Draw binary companion if it exists
            if (p.isBinary) {
              // Calculate binary position
              const binaryX = p.x + Math.cos(p.binaryPhase) * (starSize * p.binaryDistance * 3);
              const binaryY = p.y + Math.sin(p.binaryPhase) * (starSize * p.binaryDistance * 3);
              
              // Draw the secondary star (smaller)
              drawStar(binaryX, binaryY, starSize * p.binarySize, p.binaryHue, p.saturation, starLightness - 5, p.opacity * 0.9, twinkleBrightness, visibility, p.glowStrength * 0.8, p.rayIntensity * 0.7, p.rayCount - 2);
            }
          } else {
            // Draw basic particle (simple glow)
            const gradient = ctx.createRadialGradient(
              p.x, p.y, 0,
              p.x, p.y, p.size * 1.8
            );
            
            gradient.addColorStop(0, `hsla(${p.hue}, ${p.saturation}%, 75%, ${p.opacity * visibility})`);
            gradient.addColorStop(0.5, `hsla(${p.hue}, ${p.saturation - 10}%, 65%, ${p.opacity * 0.5 * visibility})`);
            gradient.addColorStop(1, `hsla(${p.hue}, ${p.saturation - 20}%, 55%, 0)`);
            
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size * 1.8, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();
          }
        }
      });
      
      // Request next frame
      requestAnimationFrame(animateParticles);
    }

    // Helper function to draw stars with rays
    function drawStar(x, y, size, hue, saturation, lightness, opacity, brightness, visibility, glowStrength, rayIntensity, rayCount) {
      // Create star gradient
      const starGradient = ctx.createRadialGradient(
        x, y, 0,
        x, y, size
      );
      
      // Center is white-ish
      starGradient.addColorStop(0, `hsla(${hue}, 10%, 95%, ${opacity * brightness * visibility})`);
      // Middle is the star color
      starGradient.addColorStop(0.4, `hsla(${hue}, ${saturation}%, ${lightness}%, ${opacity * 0.8 * brightness * visibility})`);
      // Edges fade out
      starGradient.addColorStop(1, `hsla(${hue}, ${saturation}%, ${lightness - 10}%, 0)`);
      
      // Draw the star core
      ctx.beginPath();
      ctx.arc(x, y, size * 1.5, 0, Math.PI * 2);
      ctx.fillStyle = starGradient;
      ctx.fill();
      
      // Add outer glow
      ctx.beginPath();
      ctx.arc(x, y, size * 3, 0, Math.PI * 2);
      const glowGradient = ctx.createRadialGradient(
        x, y, size,
        x, y, size * 3
      );
      glowGradient.addColorStop(0, `hsla(${hue}, ${saturation}%, ${lightness}%, ${opacity * 0.3 * glowStrength * visibility})`);
      glowGradient.addColorStop(0.5, `hsla(${hue}, ${saturation}%, ${lightness}%, ${opacity * 0.1 * glowStrength * visibility})`);
      glowGradient.addColorStop(1, `hsla(${hue}, ${saturation}%, ${lightness}%, 0)`);
      
      ctx.fillStyle = glowGradient;
      ctx.fill();
      
      // Add rays for bigger stars
      if (size > 1 && rayIntensity > 0) {
        // Calculate ray properties
        const rayLength = size * (4 + rayIntensity * 2);
        const rayWidth = size * (0.3 + rayIntensity * 0.3);
        
        // Draw rays
        ctx.save();
        ctx.translate(x, y);
        
        // Draw rays based on ray count
        const angleStep = Math.PI * 2 / rayCount;
        for (let i = 0; i < rayCount; i++) {
          const angle = i * angleStep;
          
          ctx.save();
          ctx.rotate(angle);
          
          // Draw a ray
          ctx.beginPath();
          ctx.rect(-rayLength, -rayWidth/2, rayLength * 2, rayWidth);
          
          const rayGradient = ctx.createLinearGradient(
            -rayLength, 0,
            rayLength, 0
          );
          
          rayGradient.addColorStop(0, `hsla(${hue}, ${saturation}%, ${lightness}%, 0)`);
          rayGradient.addColorStop(0.4, `hsla(${hue}, ${saturation}%, ${lightness + 10}%, ${opacity * 0.1 * rayIntensity * brightness * visibility})`);
          rayGradient.addColorStop(0.5, `hsla(${hue}, ${saturation}%, ${lightness + 10}%, ${opacity * 0.3 * rayIntensity * brightness * visibility})`);
          rayGradient.addColorStop(0.6, `hsla(${hue}, ${saturation}%, ${lightness + 10}%, ${opacity * 0.1 * rayIntensity * brightness * visibility})`);
          rayGradient.addColorStop(1, `hsla(${hue}, ${saturation}%, ${lightness}%, 0)`);
          
          ctx.fillStyle = rayGradient;
          ctx.fill();
          
          ctx.restore();
        }
        
        ctx.restore();
      }
    }

    function setupConstellation(safeMargin) {
      // Define potential constellations
      const constellations = [
        {
          name: "Ursa Major",
          points: [
            { x: 0.1, y: 0.2, size: 0.9 },  // Dubhe (α)
            { x: 0.16, y: 0.23, size: 0.8 }, // Merak (β)
            { x: 0.22, y: 0.27, size: 0.75 }, // Phecda (γ)
            { x: 0.28, y: 0.23, size: 0.7 }, // Megrez (δ)
            { x: 0.33, y: 0.18, size: 0.9 }, // Alioth (ε)
            { x: 0.41, y: 0.15, size: 0.85 }, // Mizar (ζ)
            { x: 0.46, y: 0.15, size: 0.6 }, // Alkaid (η)
            { x: 0.15, y: 0.35, size: 0.6 }, // Talitha (ι)
            { x: 0.25, y: 0.42, size: 0.6 }, // (λ)
            { x: 0.33, y: 0.38, size: 0.6 }  // (μ)
          ],
          connections: [[0,1], [1,2], [2,3], [3,4], [4,5], [5,6], [2,7], [7,8], [8,9]]
        },
        {
          name: "Orion",
          points: [
            { x: 0.5, y: 0.15, size: 1.0 },  // Betelgeuse (α)
            { x: 0.58, y: 0.11, size: 0.9 },  // Bellatrix (γ)
            { x: 0.54, y: 0.22, size: 0.7 },  // Mintaka (δ)
            { x: 0.54, y: 0.27, size: 0.8 },  // Alnilam (ε)
            { x: 0.54, y: 0.32, size: 0.75 }, // Alnitak (ζ)
            { x: 0.47, y: 0.35, size: 0.6 },  // Saiph (κ)
            { x: 0.6, y: 0.4, size: 0.95 },   // Rigel (β)
            { x: 0.44, y: 0.2, size: 0.5 },   // μ Orionis
            { x: 0.64, y: 0.2, size: 0.5 }    // ν Orionis
          ],
          connections: [[0,1], [1,2], [2,3], [3,4], [4,5], [5,6], [6,1], [0,7], [7,2], [1,8], [8,3]]
        },
        {
          name: "Cassiopeia",
          points: [
            { x: 0.7, y: 0.12, size: 0.9 },  // Shedar (α)
            { x: 0.76, y: 0.09, size: 0.85 }, // Caph (β)
            { x: 0.64, y: 0.15, size: 0.8 },  // Gamma Cas (γ)
            { x: 0.59, y: 0.22, size: 0.75 }, // Ruchbah (δ)
            { x: 0.68, y: 0.25, size: 0.8 }   // Segin (ε)
          ],
          connections: [[0,1], [0,2], [2,3], [3,4]]
        },
        {
          name: "Lyra",
          points: [
            { x: 0.3, y: 0.5, size: 1.0 },    // Vega (α)
            { x: 0.33, y: 0.54, size: 0.7 },  // (ζ)
            { x: 0.36, y: 0.58, size: 0.8 },  // (β)
            { x: 0.25, y: 0.54, size: 0.6 },  // (δ)
            { x: 0.28, y: 0.58, size: 0.7 }   // (γ)
          ],
          connections: [[0,1], [1,2], [0,3], [3,4], [4,2]]
        },
        {
          name: "Scorpius",
          points: [
            { x: 0.55, y: 0.65, size: 0.9 },  // Antares (α)
            { x: 0.5, y: 0.58, size: 0.7 },   // Graffias (β)
            { x: 0.48, y: 0.53, size: 0.6 },  // (δ)
            { x: 0.45, y: 0.5, size: 0.6 },   // (π)
            { x: 0.6, y: 0.7, size: 0.7 },    // (τ)
            { x: 0.64, y: 0.75, size: 0.7 },  // (ε)
            { x: 0.68, y: 0.78, size: 0.6 },  // (μ)
            { x: 0.72, y: 0.8, size: 0.7 },   // (ζ)
            { x: 0.75, y: 0.83, size: 0.65 }, // (η)
            { x: 0.77, y: 0.87, size: 0.6 },  // (θ)
            { x: 0.73, y: 0.86, size: 0.6 },  // (ι)
            { x: 0.7, y: 0.85, size: 0.6 }    // (κ)
          ],
          connections: [[0,1], [1,2], [2,3], [0,4], [4,5], [5,6], [6,7], [7,8], [8,9], [9,10], [10,11], [11,7]]
        },
        {
          name: "Perseus",
          points: [
            { x: 0.4, y: 0.7, size: 0.9 },    // Mirfak (α)
            { x: 0.32, y: 0.75, size: 0.95 }, // Algol (β)
            { x: 0.45, y: 0.65, size: 0.7 },  // (γ)
            { x: 0.48, y: 0.62, size: 0.7 },  // (δ)
            { x: 0.52, y: 0.6, size: 0.8 },   // (ε)
            { x: 0.35, y: 0.68, size: 0.7 },  // (ρ)
            { x: 0.3, y: 0.65, size: 0.6 }    // (η)
          ],
          connections: [[0,1], [0,2], [2,3], [3,4], [0,5], [5,6], [6,1]]
        },
        {
          name: "Ursa Minor",
          points: [
            { x: 0.15, y: 0.1, size: 1.0 },  // Polaris (α)
            { x: 0.18, y: 0.15, size: 0.7 }, // Yildun (δ)
            { x: 0.23, y: 0.17, size: 0.7 }, // Epsilon UMi (ε)
            { x: 0.26, y: 0.21, size: 0.8 }, // Zeta UMi (ζ)
            { x: 0.22, y: 0.26, size: 0.7 }, // Eta UMi (η)
            { x: 0.16, y: 0.26, size: 0.8 }, // Gamma UMi (γ)
            { x: 0.13, y: 0.21, size: 0.8 }  // Beta UMi (β)
          ],
          connections: [[0,1], [1,2], [2,3], [3,4], [4,5], [5,6], [6,0]]
        },
        {
          name: "Leo",
          points: [
            { x: 0.25, y: 0.45, size: 0.9 },  // Regulus (α)
            { x: 0.3, y: 0.4, size: 0.7 },    // Eta Leo (η)
            { x: 0.35, y: 0.37, size: 0.7 },  // Gamma Leo (γ)
            { x: 0.42, y: 0.35, size: 0.8 },  // Zeta Leo (ζ)
            { x: 0.5, y: 0.37, size: 0.85 },  // Denebola (β)
            { x: 0.42, y: 0.43, size: 0.8 },  // Delta Leo (δ)
            { x: 0.35, y: 0.47, size: 0.7 }   // Theta Leo (θ)
          ],
          connections: [[0,1], [1,2], [2,3], [3,4], [2,5], [5,6], [6,0]]
        },
        {
          name: "Gemini",
          points: [
            { x: 0.7, y: 0.35, size: 0.9 },   // Castor (α)
            { x: 0.7, y: 0.42, size: 0.9 },   // Pollux (β)
            { x: 0.65, y: 0.48, size: 0.7 },  // Alhena (γ)
            { x: 0.62, y: 0.55, size: 0.6 },  // Delta Gem (δ)
            { x: 0.77, y: 0.38, size: 0.7 },  // Epsilon Gem (ε)
            { x: 0.85, y: 0.4, size: 0.6 },   // Mu Gem (μ)
            { x: 0.87, y: 0.47, size: 0.7 },  // Xi Gem (ξ)
            { x: 0.83, y: 0.53, size: 0.6 }   // Lambda Gem (λ)
          ],
          connections: [[0,1], [1,2], [2,3], [0,4], [4,5], [5,6], [6,7], [7,3]]
        },
        {
          name: "Taurus",
          points: [
            { x: 0.5, y: 0.7, size: 1.0 },    // Aldebaran (α)
            { x: 0.55, y: 0.67, size: 0.7 },  // Epsilon Tau (ε)
            { x: 0.6, y: 0.65, size: 0.6 },   // Gamma Tau (γ)
            { x: 0.65, y: 0.63, size: 0.65 }, // Lambda Tau (λ)
            { x: 0.7, y: 0.62, size: 0.7 },   // Xi Tau (ξ)
            { x: 0.58, y: 0.76, size: 0.8 },  // Beta Tau (β)
            { x: 0.65, y: 0.71, size: 0.7 },  // Zeta Tau (ζ)
            { x: 0.42, y: 0.73, size: 0.6 }   // Theta Tau (θ)
          ],
          connections: [[0,1], [1,2], [2,3], [3,4], [0,5], [5,6], [0,7]]
        },
        {
          name: "Pegasus",
          points: [
            { x: 0.8, y: 0.6, size: 0.8 },    // Markab (α)
            { x: 0.9, y: 0.6, size: 0.8 },    // Scheat (β)
            { x: 0.9, y: 0.7, size: 0.8 },    // Algenib (γ)
            { x: 0.8, y: 0.7, size: 0.9 },    // Alpheratz (δ)
            { x: 0.75, y: 0.65, size: 0.7 },  // Eta Peg (η)
            { x: 0.7, y: 0.55, size: 0.6 }    // Theta Peg (θ)
          ],
          connections: [[0,1], [1,2], [2,3], [3,0], [0,4], [4,5]]
        },
        {
          name: "Draco",
          points: [
            { x: 0.1, y: 0.4, size: 0.8 },    // Thuban (α)
            { x: 0.15, y: 0.45, size: 0.7 },  // (ι)
            { x: 0.2, y: 0.5, size: 0.7 },    // (θ)
            { x: 0.25, y: 0.55, size: 0.7 },  // (η)
            { x: 0.3, y: 0.6, size: 0.8 },    // (ζ)
            { x: 0.33, y: 0.65, size: 0.7 },  // (β)
            { x: 0.28, y: 0.7, size: 0.8 },   // (γ)
            { x: 0.23, y: 0.73, size: 0.7 },  // (ξ)
            { x: 0.18, y: 0.71, size: 0.7 },  // (ν)
            { x: 0.14, y: 0.67, size: 0.8 },  // (δ)
            { x: 0.11, y: 0.62, size: 0.7 },  // (ε)
            { x: 0.05, y: 0.6, size: 0.7 }    // (τ)
          ],
          connections: [[0,1], [1,2], [2,3], [3,4], [4,5], [5,6], [6,7], [7,8], [8,9], [9,10], [10,11]]
        },
        {
          name: "Aquarius",
          points: [
            { x: 0.7, y: 0.8, size: 0.8 },    // Sadalmelik (α)
            { x: 0.65, y: 0.83, size: 0.7 },  // (γ)
            { x: 0.6, y: 0.86, size: 0.7 },   // (η)
            { x: 0.55, y: 0.89, size: 0.8 },  // (ζ)
            { x: 0.75, y: 0.82, size: 0.7 },  // (ε)
            { x: 0.78, y: 0.85, size: 0.7 },  // (β)
            { x: 0.82, y: 0.88, size: 0.7 },  // (θ)
            { x: 0.77, y: 0.78, size: 0.75 }, // (δ)
            { x: 0.82, y: 0.76, size: 0.7 },  // (λ)
            { x: 0.86, y: 0.73, size: 0.7 }   // (φ)
          ],
          connections: [[0,1], [1,2], [2,3], [0,4], [4,5], [5,6], [0,7], [7,8], [8,9]]
        },
        {
          name: "Sagittarius",
          points: [
            { x: 0.4, y: 0.8, size: 0.8 },    // Rukbat (α)
            { x: 0.44, y: 0.83, size: 0.7 },  // (β)
            { x: 0.48, y: 0.86, size: 0.7 },  // (γ)
            { x: 0.43, y: 0.89, size: 0.7 },  // (δ)
            { x: 0.38, y: 0.86, size: 0.7 },  // (ε)
            { x: 0.35, y: 0.82, size: 0.7 },  // (ζ)
            { x: 0.32, y: 0.85, size: 0.75 }, // (φ)
            { x: 0.37, y: 0.91, size: 0.75 }, // (η)
            { x: 0.42, y: 0.92, size: 0.7 }   // (θ)
          ],
          connections: [[0,1], [1,2], [2,3], [3,4], [4,5], [5,0], [4,6], [3,7], [7,8]]
        }
      ];
      
      // Choose a random constellation
      const chosen = constellations[Math.floor(Math.random() * constellations.length)];
      constellationName = chosen.name;
      
      // Calculate size and position for the constellation
      // Make sure it's not in the safe margin
      let validPosition = false;
      let offsetX, offsetY, scale;
      
      while (!validPosition) {
        // Determine scale and position
        scale = 200 + Math.random() * 200; // Reduced from 300-600 to 200-400 range
        offsetX = Math.random() * (canvas.width - scale);
        offsetY = Math.random() * (canvas.height - scale);
        
        // Check if constellation is in safe zone
        let inSafeZone = false;
        for (const point of chosen.points) {
          const x = offsetX + point.x * scale;
          const y = offsetY + point.y * scale;
          
          if (x > safeMargin.left && x < safeMargin.right && 
              y > safeMargin.top && y < safeMargin.bottom) {
            inSafeZone = true;
            break;
          }
        }
        
        validPosition = !inSafeZone;
      }
      
      // Create the constellation particles
      for (let i = 0; i < chosen.points.length; i++) {
        const point = chosen.points[i];
        
        // Convert relative positions to absolute positions
        const x = offsetX + point.x * scale;
        const y = offsetY + point.y * scale;
        
        // Add a star particle at this position
        const size = 1.5 + point.size * 1.8; // Larger stars for constellation
        const baseHue = 180 + Math.random() * 60; // Cyan to light blue
        
        const constellationStar = {
          x: x,
          y: y,
          baseSize: size,
          size: size,
          maxSize: size * 1.8,
          speedX: (Math.random() - 0.5) * 0.01, // Very slow movement
          speedY: (Math.random() - 0.5) * 0.01,
          opacity: 0.9, // Increased opacity
          growFactor: 0,
          hue: baseHue,
          saturation: 70 + Math.random() * 30,
          lightness: 80 + Math.random() * 15, // Increased lightness
          glowStrength: 1.2 + Math.random() * 0.5, // Increased glow
          pulsing: true,
          twinkleSpeed: 0.003 + Math.random() * 0.003,
          twinklePhase: Math.random() * Math.PI * 2,
          rayIntensity: 0.8 + Math.random() * 0.5, // Increased ray intensity
          rayCount: 8, // More rays for constellation stars
          depth: 1.0, // Full depth
          isPlanet: false,
          isStar: true,
          isBasic: false,
          inConstellation: true,
          constellationIndex: i
        };
        
        particles.push(constellationStar);
      }
      
      // Store constellation data
      constellationPoints = chosen.points.map((p, i) => ({
        x: offsetX + p.x * scale,
        y: offsetY + p.y * scale,
        index: i
      }));
      
      // Store connections
      constellationConnections = chosen.connections;
    }

    function drawConstellation() {
      if (!hasRareConstellation || !constellationPoints || constellationPoints.length === 0) return;
      
      // First draw the connections between stars
      ctx.save();
      
      // Find the constellation particles for current positions
      const starPositions = particles
        .filter(p => p.inConstellation)
        .map(p => ({ x: p.x, y: p.y, index: p.constellationIndex }));
      
      // Draw each connection
      for (const [fromIdx, toIdx] of constellationConnections) {
        const from = starPositions.find(s => s.index === fromIdx);
        const to = starPositions.find(s => s.index === toIdx);
        
        if (from && to) {
          // Calculate opacity based on cursor distance
          const midX = (from.x + to.x) / 2;
          const midY = (from.y + to.y) / 2;
          const dx = mousePosition.x - midX;
          const dy = mousePosition.y - midY;
          const distanceToCursor = Math.sqrt(dx * dx + dy * dy);
          const lightRadius = 500; // Increased light radius
          
          // Base visibility with minimum value
          let visibility = Math.max(0.3, Math.min(1, 1 - (distanceToCursor / lightRadius)));
          
          // Draw outer glow behind the line
          ctx.beginPath();
          ctx.moveTo(from.x, from.y);
          ctx.lineTo(to.x, to.y);
          ctx.strokeStyle = `rgba(120, 190, 255, ${visibility * 0.4})`;
          ctx.lineWidth = 12;
          ctx.setLineDash([]);
          ctx.stroke();
          
          // Draw line with glow effect
          ctx.beginPath();
          ctx.moveTo(from.x, from.y);
          ctx.lineTo(to.x, to.y);
          
          // Line with glow effect
          ctx.strokeStyle = `rgba(140, 200, 255, ${visibility * 0.7})`; // Increased brightness
          ctx.lineWidth = 2;
          ctx.setLineDash([]);
          ctx.stroke();
          
          // Glow effect
          ctx.beginPath();
          ctx.moveTo(from.x, from.y);
          ctx.lineTo(to.x, to.y);
          ctx.strokeStyle = `rgba(140, 210, 255, ${visibility * 0.4})`;
          ctx.lineWidth = 6;
          ctx.stroke();
          
          // Add subtle pulse effect to the connections
          const pulseTime = Date.now() * 0.001; // convert to seconds
          const pulseSpeed = 0.5; // How fast the pulse moves
          const dashLength = 20; // Length of the dash
          
          // Create a moving dash effect along the line
          ctx.beginPath();
          ctx.moveTo(from.x, from.y);
          ctx.lineTo(to.x, to.y);
          ctx.strokeStyle = `rgba(200, 230, 255, ${visibility * 0.9})`; // Brighter dash
          ctx.lineWidth = 3; // Thicker line
          
          // Calculate moving dash pattern
          const distance = Math.sqrt(Math.pow(to.x - from.x, 2) + Math.pow(to.y - from.y, 2));
          const dashOffset = (pulseTime * pulseSpeed * 100) % (distance * 2);
          ctx.setLineDash([dashLength, distance - dashLength]);
          ctx.lineDashOffset = dashOffset;
          ctx.stroke();
        }
      }
      
      // Draw additional outer glow around the entire constellation
      if (starPositions.length > 0) {
        // Find the center and radius of the constellation
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        
        starPositions.forEach(pos => {
          minX = Math.min(minX, pos.x);
          minY = Math.min(minY, pos.y);
          maxX = Math.max(maxX, pos.x);
          maxY = Math.max(maxY, pos.y);
        });
        
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        const radius = Math.max(maxX - minX, maxY - minY) / 1.5;
        
        // Draw subtle outer glow
        const constellationGlow = ctx.createRadialGradient(
          centerX, centerY, radius * 0.5,
          centerX, centerY, radius * 1.5
        );
        
        constellationGlow.addColorStop(0, 'rgba(100, 180, 255, 0.1)');
        constellationGlow.addColorStop(0.6, 'rgba(100, 180, 255, 0.05)');
        constellationGlow.addColorStop(1, 'rgba(100, 180, 255, 0)');
        
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius * 1.5, 0, Math.PI * 2);
        ctx.fillStyle = constellationGlow;
        ctx.fill();
      }
      
      // Draw constellation name
      if (constellationName) {
        // Find average position of stars to place the name
        let avgX = 0, avgY = 0;
        starPositions.forEach(pos => {
          avgX += pos.x;
          avgY += pos.y;
        });
        avgX /= starPositions.length;
        avgY /= starPositions.length - 20; // Position slightly above
        
        // Calculate opacity based on cursor distance
        const dx = mousePosition.x - avgX;
        const dy = mousePosition.y - avgY;
        const distanceToCursor = Math.sqrt(dx * dx + dy * dy);
        const lightRadius = 500; // Increased light radius
        let visibility = Math.max(0.25, Math.min(1, 1 - (distanceToCursor / lightRadius)));
        
        // Add text with stronger glow
        ctx.font = "bold 18px Helvetica, Arial, sans-serif";
        ctx.textAlign = "center";
        // Add glow effect
        ctx.shadowColor = "rgba(140, 200, 255, 0.9)";
        ctx.shadowBlur = 15;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        
        // Draw outline
        ctx.lineWidth = 2;
        ctx.strokeStyle = `rgba(40, 100, 200, ${visibility * 0.6})`;
        ctx.strokeText(constellationName, avgX, avgY);
        
        // Draw text
        ctx.fillStyle = `rgba(220, 240, 255, ${visibility * 0.95})`;
        ctx.fillText(constellationName, avgX, avgY);
        
        // Reset shadow
        ctx.shadowBlur = 0;
      }
      
      ctx.restore();
    }

    // Initialize everything once DOM is loaded
    document.addEventListener('DOMContentLoaded', () => {
      // Only set up cursor effects on desktop
      if (!isMobileOrTablet()) {
        document.addEventListener('mousemove', handleMouseMove);
        initializeCursorEffects();
        
        // Initialize particles
        initParticles();
      }
      
      // Fix for 100vh issue on mobile
      function setVhVariable() {
        let vh = window.innerHeight * 0.01;
        document.documentElement.style.setProperty('--vh', `${vh}px`);
      }
      
      // Set initial height and update on resize
      setVhVariable();
      window.addEventListener('resize', setVhVariable);
    });
  </script>
</body>
</html>